(function(){"use strict";function v(r){return r[Math.floor(Math.random()*r.length)]}class M{constructor(t,e){this.width=t,this.height=e,this.cells=Array.from({length:e},()=>Array.from({length:t},()=>({walls:{N:!0,E:!0,S:!0,W:!0},wallCount:4,highlighted:!1})))}cells;removeWall(t,e,o){const s=this.cells[e][t];if(s.walls[o]){s.walls[o]=!1,s.wallCount--;const l=y[o],i=t+l.xd,n=e+l.yd;n>=0&&n<this.height&&i>=0&&i<this.width&&(this.cells[n][i].walls[l.oDir]=!1,this.cells[n][i].wallCount--)}}getSegments(){const t=[];for(let e=0;e<this.height;e++)for(let o=0;o<this.width;o++){const s=this.cells[e][o];e===0&&s.walls.N&&t.push({p1:{x:o,y:e},p2:{x:o+1,y:e}}),o===0&&s.walls.W&&t.push({p1:{x:o,y:e},p2:{x:o,y:e+1}}),s.walls.E&&t.push({p1:{x:o+1,y:e},p2:{x:o+1,y:e+1}}),s.walls.S&&t.push({p1:{x:o,y:e+1},p2:{x:o+1,y:e+1}})}return t}}const P=["N","E","S","W"],d=[{dir:"N",xd:0,yd:-1,oDir:"S"},{dir:"E",xd:1,yd:0,oDir:"W"},{dir:"S",xd:0,yd:1,oDir:"N"},{dir:"W",xd:-1,yd:0,oDir:"E"}],y={N:d[0],E:d[1],S:d[2],W:d[3]};class g{constructor(t){this.maze=t}randomize(t){const e=Array.from(t,(o,s)=>({index:s,rank:Math.random()}));return e.sort((o,s)=>o.rank-s.rank),e.map(({index:o})=>t[o])}randomizeDirections(){return this.randomize(P)}}class k extends g{startTime=Date.now();count=0;getNextWallToRemove(){const t=this.maze,e=t.width,o=t.height;let s=0,l=Math.floor(Math.random()*e),i=Math.floor(Math.random()*o),n=Math.floor(Math.random()*4),a=t.cells[i][l],h=d[n],u=l+h.xd,c=i+h.yd;for(;(a.walls[h.dir]===!1||a.wallCount<3||c>=0&&c<o&&u>=0&&u<e&&t.cells[c][u].wallCount<3)&&s<100;)l=Math.floor(Math.random()*e),i=Math.floor(Math.random()*o),a=t.cells[i][l],n=Math.floor(Math.random()*4),h=d[n],u=l+h.xd,c=i+h.yd,s++;if(s>=100){console.log(`Giving up on finding walls to remove - total time: ${Date.now()-this.startTime}ms for ${this.count} walls removed`);return}return t.removeWall(l,i,h.dir),this.count++,{x:l,y:i,dir:h.dir}}}class z extends g{startTime=Date.now();count=0;parent;currentPos={x:0,y:-1};complete=!1;constructor(t){super(t),this.parent=Array.from({length:t.height},()=>Array.from({length:t.width},()=>({pair:{x:-1,y:-1},depth:-1})))}getNextWallToRemove(){if(this.complete)return;let t;if(this.currentPos.y===-1)t={x:0,y:Math.floor(Math.random()*this.maze.height),dir:"W"},this.currentPos.y=t.y,this.parent[t.y][t.x].depth=0;else{let e=!1;do{const o=this.maze.cells[this.currentPos.y][this.currentPos.x],s=this.parent[this.currentPos.y][this.currentPos.x].depth+1;let l;for(const i of this.randomizeDirections()){if(!o.walls[i])continue;l=y[i];const n=this.currentPos.x+l.xd,a=this.currentPos.y+l.yd;if(!(n<0||a<0||n>=this.maze.width||a>=this.maze.height)&&this.parent[a][n].depth===-1){this.count++,t={...this.currentPos,dir:i},this.parent[a][n]={pair:this.currentPos,depth:s},this.currentPos={x:n,y:a},e=!0;break}}if(!e){const i=this.parent[this.currentPos.y][this.currentPos.x],n=this.maze.width-1;if(this.currentPos={...i.pair},this.currentPos.y===-1){let a=[],h=0;for(let c=0;c<this.maze.height;c++){const w=this.parent[c][n].depth;w>h&&(a=[],h=w),w===h&&a.push(c)}const u=v(a);t={x:n,y:u,dir:"E"},console.log(`RecursiveBacktracking complete - total time: ${Date.now()-this.startTime}ms for ${this.count} walls removed`),this.complete=!0,e=!0}}}while(!e)}return t&&this.maze.removeWall(t.x,t.y,t.dir),t}}async function W(r){if(!(r<=0))if(r<=10){const t=performance.now();for(;performance.now()-t<r;);}else return new Promise(t=>setTimeout(t,r))}let x=0,m,f="stopped",p;self.onmessage=function({data:{method:r,maze:t,algorithm:e,delay:o=0}}){if(o!==void 0&&(x=o),t!==void 0&&(m=t,Object.setPrototypeOf(m,M.prototype)),e!==void 0&&!p)switch(e){case"Random":p=new k(m);break;case"RecursiveBacktracking":p=new z(m);break;default:p=null,console.error(`Unknown algorithm: ${e}`);return}switch(r){case"play":f="playing",N();break;case"stop":f="stopped";break}};function D(){const r=p?.getNextWallToRemove();if(r===void 0){f="stopped",self.postMessage({method:"done"});return}else return self.postMessage({...r,method:"removeWall"}),r}async function N(){for(;f==="playing";){const r=performance.now();if(!D()){f="stopped",self.postMessage({method:"done"});return}await W(x-(performance.now()-r))}}})();
