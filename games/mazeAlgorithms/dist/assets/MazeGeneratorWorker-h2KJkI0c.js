(function(){"use strict";function M(o){return o[Math.floor(Math.random()*o.length)]}class v{constructor(t,e){this.width=t,this.height=e,this.cells=Array.from({length:e},()=>Array.from({length:t},()=>({walls:{N:!0,E:!0,S:!0,W:!0},wallCount:4,highlighted:!1})))}cells;removeWall(t,e,s){const i=this.cells[e][t];if(i.walls[s]){i.walls[s]=!1,i.wallCount--;const n=w[s],r=t+n.xd,l=e+n.yd;l>=0&&l<this.height&&r>=0&&r<this.width&&(this.cells[l][r].walls[n.oDir]=!1,this.cells[l][r].wallCount--)}}getSegments(){const t=[];for(let e=0;e<this.height;e++)for(let s=0;s<this.width;s++){const i=this.cells[e][s];e===0&&i.walls.N&&t.push({p1:{x:s,y:e},p2:{x:s+1,y:e}}),s===0&&i.walls.W&&t.push({p1:{x:s,y:e},p2:{x:s,y:e+1}}),i.walls.E&&t.push({p1:{x:s+1,y:e},p2:{x:s+1,y:e+1}}),i.walls.S&&t.push({p1:{x:s,y:e+1},p2:{x:s+1,y:e+1}})}return t}}const C=["N","E","S","W"],u=[{dir:"N",xd:0,yd:-1,oDir:"S"},{dir:"E",xd:1,yd:0,oDir:"W"},{dir:"S",xd:0,yd:1,oDir:"N"},{dir:"W",xd:-1,yd:0,oDir:"E"}],w={N:u[0],E:u[1],S:u[2],W:u[3]};class g{constructor(t){this.maze=t}COLORS={empty:"rgb(0, 0, 0)",start:"rgb(150, 255, 150)",partial:"rgb(150, 150, 255)",current:"rgb(50, 50, 255)",end:"rgb(255, 150, 150)",finished:"rgb(255, 255, 255)"};randomize(t){const e=Array.from(t,(s,i)=>({index:i,rank:Math.random()}));return e.sort((s,i)=>s.rank-i.rank),e.map(({index:s})=>t[s])}randomizeDirections(){return this.randomize(C)}colorCell(t,e,s){self.postMessage({method:"colorCell",x:t,y:e,color:s})}}class P extends g{startTime=Date.now();count=0;getNextWallToRemove(){const t=this.maze,e=t.width,s=t.height;let i=0,n=Math.floor(Math.random()*e),r=Math.floor(Math.random()*s),l=Math.floor(Math.random()*4),a=t.cells[r][n],h=u[l],d=n+h.xd,c=r+h.yd;for(;(a.walls[h.dir]===!1||a.wallCount<3||c>=0&&c<s&&d>=0&&d<e&&t.cells[c][d].wallCount<3)&&i<100;)n=Math.floor(Math.random()*e),r=Math.floor(Math.random()*s),a=t.cells[r][n],l=Math.floor(Math.random()*4),h=u[l],d=n+h.xd,c=r+h.yd,i++;if(i>=100){console.log(`Giving up on finding walls to remove - total time: ${Date.now()-this.startTime}ms for ${this.count} walls removed`);return}return t.removeWall(n,r,h.dir),this.colorCell(n,r,this.COLORS.finished),this.colorCell(d,c,this.COLORS.finished),this.count++,{x:n,y:r,dir:h.dir}}}class k extends g{startTime=Date.now();count=0;parent;currentPos={x:0,y:-1};complete=!1;constructor(t){super(t),this.parent=Array.from({length:t.height},()=>Array.from({length:t.width},()=>({pair:{x:-1,y:-1},depth:-1})))}getNextWallToRemove(){if(this.complete)return;let t;if(this.currentPos.y===-1)t={x:0,y:Math.floor(Math.random()*this.maze.height),dir:"W"},this.currentPos.y=t.y,this.parent[t.y][t.x].depth=0,this.colorCell(0,t.y,this.COLORS.start);else{let e=!1;do{const s=this.maze.cells[this.currentPos.y][this.currentPos.x],i=this.parent[this.currentPos.y][this.currentPos.x].depth+1;let n;for(const r of this.randomizeDirections()){if(!s.walls[r])continue;n=w[r];const l=this.currentPos.x+n.xd,a=this.currentPos.y+n.yd;if(!(l<0||a<0||l>=this.maze.width||a>=this.maze.height)&&this.parent[a][l].depth===-1){this.count++,t={...this.currentPos,dir:r},this.parent[a][l]={pair:this.currentPos,depth:i},this.currentPos={x:l,y:a},e=!0;break}}if(e)this.colorCell(this.currentPos.x,this.currentPos.y,this.COLORS.partial);else{const r=this.parent[this.currentPos.y][this.currentPos.x],l=this.maze.width-1;if(r.pair.y===-1){let a=[],h=0;for(let c=0;c<this.maze.height;c++){const y=this.parent[c][l].depth;y>h&&(a=[],h=y),y===h&&a.push(c)}const d=M(a);this.colorCell(l,d,this.COLORS.end),t={x:l,y:d,dir:"E"},console.log(`RecursiveBacktracking complete - total time: ${Date.now()-this.startTime}ms for ${this.count} walls removed`),this.complete=!0,e=!0}else this.colorCell(this.currentPos.x,this.currentPos.y,this.COLORS.finished);this.currentPos={...r.pair}}}while(!e)}return t&&this.maze.removeWall(t.x,t.y,t.dir),t}}async function z(o){if(!(o<=0))if(o<=10){const t=performance.now();for(;performance.now()-t<o;);}else return new Promise(t=>setTimeout(t,o))}let x=0,m,f="stopped",p;self.onmessage=function({data:{method:o,maze:t,algorithm:e,delay:s=0}}){if(s!==void 0&&(x=s),t!==void 0&&(m=t,Object.setPrototypeOf(m,v.prototype)),e!==void 0&&!p)switch(e){case"Random":p=new P(m);break;case"RecursiveBacktracking":p=new k(m);break;default:p=null,console.error(`Unknown algorithm: ${e}`);return}switch(o){case"play":f="playing",R();break;case"stop":f="stopped";break}};function O(){const o=p?.getNextWallToRemove();if(o===void 0){f="stopped",self.postMessage({method:"done"});return}else return self.postMessage({...o,method:"removeWall"}),o}async function R(){for(;f==="playing";){const o=performance.now();if(!O()){f="stopped",self.postMessage({method:"done"});return}await z(x-(performance.now()-o))}}})();
