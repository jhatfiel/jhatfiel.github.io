(function(){"use strict";class v{constructor(t,e){this.width=t,this.height=e,this.cells=Array.from({length:e},()=>Array.from({length:t},()=>({walls:{N:!0,E:!0,S:!0,W:!0},wallCount:4,highlighted:!1})))}cells;removeWall(t,e,o){const a=this.cells[e][t];if(a.walls[o]){a.walls[o]=!1,a.wallCount--;const n=y[o],r=t+n.xd,s=e+n.yd;s>=0&&s<this.height&&r>=0&&r<this.width&&(this.cells[s][r].walls[n.oDir]=!1,this.cells[s][r].wallCount--)}}}const M=["N","E","S","W"],d=[{dir:"N",xd:0,yd:-1,oDir:"S"},{dir:"E",xd:1,yd:0,oDir:"W"},{dir:"S",xd:0,yd:1,oDir:"N"},{dir:"W",xd:-1,yd:0,oDir:"E"}],y={N:d[0],E:d[1],S:d[2],W:d[3]};class g{constructor(t){this.maze=t}pick(t){return t[Math.floor(Math.random()*t.length)]}randomize(t){const e=Array.from(t,(o,a)=>({index:a,rank:Math.random()}));return e.sort((o,a)=>o.rank-a.rank),e.map(({index:o})=>t[o])}randomizeDirections(){return this.randomize(M)}}class P extends g{startTime=Date.now();count=0;getNextWallToRemove(){const t=this.maze,e=t.width,o=t.height;let a=0,n=Math.floor(Math.random()*e),r=Math.floor(Math.random()*o),s=Math.floor(Math.random()*4),l=t.cells[r][n],c=d[s],u=n+c.xd,h=r+c.yd;for(;(l.walls[c.dir]===!1||l.wallCount<3||h>=0&&h<o&&u>=0&&u<e&&t.cells[h][u].wallCount<3)&&a<100;)n=Math.floor(Math.random()*e),r=Math.floor(Math.random()*o),l=t.cells[r][n],s=Math.floor(Math.random()*4),c=d[s],u=n+c.xd,h=r+c.yd,a++;if(a>=100){console.log(`Giving up on finding walls to remove - total time: ${Date.now()-this.startTime}ms for ${this.count} walls removed`);return}return t.removeWall(n,r,c.dir),this.count++,{x:n,y:r,dir:c.dir}}}class k extends g{startTime=Date.now();count=0;parent;currentPos={x:0,y:-1};complete=!1;constructor(t){super(t),this.parent=Array.from({length:t.height},()=>Array.from({length:t.width},()=>({pair:{x:-1,y:-1},depth:-1})))}getNextWallToRemove(){if(this.complete)return;let t;if(this.currentPos.y===-1)t={x:0,y:Math.floor(Math.random()*this.maze.height),dir:"W"},this.currentPos.y=t.y,this.parent[t.y][t.x].depth=0;else{let e=!1;do{const o=this.maze.cells[this.currentPos.y][this.currentPos.x],a=this.parent[this.currentPos.y][this.currentPos.x].depth+1;let n;for(const r of this.randomizeDirections()){if(!o.walls[r])continue;n=y[r];const s=this.currentPos.x+n.xd,l=this.currentPos.y+n.yd;if(!(s<0||l<0||s>=this.maze.width||l>=this.maze.height)&&this.parent[l][s].depth===-1){this.count++,t={...this.currentPos,dir:r},this.parent[l][s]={pair:this.currentPos,depth:a},this.currentPos={x:s,y:l},e=!0;break}}if(!e){const r=this.parent[this.currentPos.y][this.currentPos.x],s=this.maze.width-1;if(this.currentPos={...r.pair},this.currentPos.y===-1){let l=[],c=0;for(let h=0;h<this.maze.height;h++){const w=this.parent[h][s].depth;w>c&&(l=[],c=w),w===c&&l.push(h)}const u=this.pick(l);t={x:s,y:u,dir:"E"},console.log(`RecursiveBacktracking complete - total time: ${Date.now()-this.startTime}ms for ${this.count} walls removed`),this.complete=!0,e=!0}}}while(!e)}return t&&this.maze.removeWall(t.x,t.y,t.dir),t}}async function z(i){if(!(i<=0))if(i<=10){const t=performance.now();for(;performance.now()-t<i;);}else return new Promise(t=>setTimeout(t,i))}let x=0,m,f="stopped",p;self.onmessage=function({data:{method:i,maze:t,algorithm:e,delay:o=0}}){if(o!==void 0&&(x=o),t!==void 0&&(m=t,Object.setPrototypeOf(m,v.prototype)),e!==void 0)switch(e){case"Random":p=new P(m);break;case"RecursiveBacktracking":p=new k(m);break;default:p=null,console.error(`Unknown algorithm: ${e}`);return}switch(i){case"play":f="playing",D();break;case"stop":f="stopped";break}};function W(){const i=p?.getNextWallToRemove();if(i===void 0){f="stopped",self.postMessage({method:"done"});return}else return self.postMessage({...i,method:"removeWall"}),i}async function D(){for(;f==="playing";){const i=performance.now();if(!W()){f="stopped",self.postMessage({method:"done"});return}await z(x-(performance.now()-i))}}})();
