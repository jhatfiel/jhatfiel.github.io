(function(){"use strict";function k(n){return n[Math.floor(Math.random()*n.length)]}class W{constructor(t,e){this.width=t,this.height=e,this.cells=Array.from({length:e},()=>Array.from({length:t},()=>({walls:{N:!0,E:!0,S:!0,W:!0},wallCount:4,highlighted:!1})))}cells;removeWall(t,e,s){const l=this.cells[e][t];if(l.walls[s]){l.walls[s]=!1,l.wallCount--;const r=p[s],i=t+r.xd,o=e+r.yd;o>=0&&o<this.height&&i>=0&&i<this.width&&(this.cells[o][i].walls[r.oDir]=!1,this.cells[o][i].wallCount--)}}getSegments(){const t=[];for(let e=0;e<this.height;e++)for(let s=0;s<this.width;s++){const l=this.cells[e][s];e===0&&l.walls.N&&t.push({p1:{x:s,y:e},p2:{x:s+1,y:e}}),s===0&&l.walls.W&&t.push({p1:{x:s,y:e},p2:{x:s,y:e+1}}),l.walls.E&&t.push({p1:{x:s+1,y:e},p2:{x:s+1,y:e+1}}),l.walls.S&&t.push({p1:{x:s,y:e+1},p2:{x:s+1,y:e+1}})}return t}}const g=["N","E","S","W"],f=[{dir:"N",xd:0,yd:-1,oDir:"S"},{dir:"E",xd:1,yd:0,oDir:"W"},{dir:"S",xd:0,yd:1,oDir:"N"},{dir:"W",xd:-1,yd:0,oDir:"E"}],p={N:f[0],E:f[1],S:f[2],W:f[3]};class w{constructor(t){this.maze=t}startTime=Date.now();count=0;COLORS={empty:"rgb(0, 0, 0)",start:"rgb(150, 255, 150)",partial:"rgb(150, 150, 255)",current:"rgb(50, 50, 255)",end:"rgb(255, 150, 150)",finished:"rgb(255, 255, 255)"};randomize(t){return Array.from(t,(e,s)=>({index:s,rank:Math.random()})).sort((e,s)=>e.rank-s.rank).map(({index:e})=>t[e])}randomizeDirections(){return this.randomize(g)}randomizeValidDirections(t){const e=[];return t.x>0&&e.push("W"),t.x<this.maze.width-1&&e.push("E"),t.y>0&&e.push("N"),t.y<this.maze.height-1&&e.push("S"),this.randomize(e)}removeWall(t,e,s){this.count++,self.postMessage({method:"removeWall",x:t,y:e,dir:s}),this.maze.removeWall(t,e,s)}colorCell(t,e,s){self.postMessage({method:"colorCell",x:t,y:e,color:s})}}class O extends w{startTime=Date.now();count=0;performNextStep(){const t=this.maze,e=t.width,s=t.height;let l=0,r=Math.floor(Math.random()*e),i=Math.floor(Math.random()*s),o=Math.floor(Math.random()*4),a=t.cells[i][r],h=f[o],u=r+h.xd,c=i+h.yd;for(;(a.walls[h.dir]===!1||a.wallCount<3||c>=0&&c<s&&u>=0&&u<e&&t.cells[c][u].wallCount<3)&&l<100;)r=Math.floor(Math.random()*e),i=Math.floor(Math.random()*s),a=t.cells[i][r],o=Math.floor(Math.random()*4),h=f[o],u=r+h.xd,c=i+h.yd,l++;return l>=100?(console.log(`Giving up on finding walls to remove - total time: ${Date.now()-this.startTime}ms for ${this.count} walls removed`),!1):(this.removeWall(r,i,h.dir),this.colorCell(r,i,this.COLORS.finished),this.colorCell(u,c,this.COLORS.finished),this.count++,!0)}}class P extends w{parent;currentPos={x:0,y:-1};complete=!1;constructor(t){super(t),this.parent=Array.from({length:t.height},()=>Array.from({length:t.width},()=>({pair:{x:-1,y:-1},depth:-1})))}performNextStep(){if(this.complete)return!1;let t;if(this.currentPos.y===-1)t={x:0,y:Math.floor(Math.random()*this.maze.height),dir:"W"},this.currentPos.y=t.y,this.parent[t.y][t.x].depth=0,this.colorCell(0,t.y,this.COLORS.start);else{let e=!1;do{const s=this.maze.cells[this.currentPos.y][this.currentPos.x],l=this.parent[this.currentPos.y][this.currentPos.x].depth+1;let r;for(const i of this.randomizeDirections()){if(!s.walls[i])continue;r=p[i];const o=this.currentPos.x+r.xd,a=this.currentPos.y+r.yd;if(!(o<0||a<0||o>=this.maze.width||a>=this.maze.height)&&this.parent[a][o].depth===-1){t={...this.currentPos,dir:i},this.parent[a][o]={pair:this.currentPos,depth:l},this.currentPos={x:o,y:a},e=!0;break}}if(e)this.colorCell(this.currentPos.x,this.currentPos.y,this.COLORS.partial);else{const i=this.parent[this.currentPos.y][this.currentPos.x],o=this.maze.width-1;if(i.pair.y===-1){let a=[],h=0;for(let c=0;c<this.maze.height;c++){const C=this.parent[c][o].depth;C>h&&(a=[],h=C),C===h&&a.push(c)}const u=k(a);this.colorCell(o,u,this.COLORS.end),t={x:o,y:u,dir:"E"},this.complete=!0,e=!0}else this.colorCell(this.currentPos.x,this.currentPos.y,this.COLORS.finished);this.currentPos={...i.pair}}}while(!e)}return t&&this.removeWall(t.x,t.y,t.dir),t!==void 0}}class S extends w{startTime=Date.now();count=0;complete=!1;randomizedCells;contained=[];directionForCurrentWalk=[];currentWalkTouched=[];walkPos;startWalkPos;state="START";constructor(t){super(t);const e=[];for(let s=0;s<t.width;s++)for(let l=0;l<t.height;l++)e.push({pair:{x:s,y:l},order:Math.random()});e.sort((s,l)=>s.order-l.order),this.randomizedCells=e.map(({pair:s})=>s)}isContained(t){return t!==void 0&&this.contained[t.y*this.maze.width+t.x]===!0}setContained(t){this.contained[t.y*this.maze.width+t.x]=!0}pruneCurrentWalkTouchedAfter(t){const e=this.currentWalkTouched.findIndex(s=>s.x===t.x&&s.y===t.y);e!==-1&&this.currentWalkTouched.splice(e,this.currentWalkTouched.length).forEach(s=>this.colorCell(s.x,s.y,this.COLORS.empty))}setDirectionForCurrentWalk(t,e){const s=t.y*this.maze.width+t.x;this.directionForCurrentWalk[s]!==void 0&&this.pruneCurrentWalkTouchedAfter(t),this.currentWalkTouched.push(t),this.directionForCurrentWalk[s]=e}getDirectionForCurrentWalk(t){return this.directionForCurrentWalk[t.y*this.maze.width+t.x]}clearCurrentWalk(){this.currentWalkTouched=[],this.directionForCurrentWalk=[]}performNextStep(){switch(this.state){case"START":this.selectStartCell();break;case"STARTWALK":this.startWalk();break;case"WALK":this.walk();break}if(this.state==="DONE"){let t=Math.floor(Math.random()*this.maze.height);this.removeWall(0,t,"W"),this.colorCell(0,t,this.COLORS.start);const e=this.maze.width-1;return t=Math.floor(Math.random()*this.maze.height),this.removeWall(e,t,"E"),this.colorCell(e,t,this.COLORS.end),!1}else return!0}selectStartCell(){const t=this.randomizedCells.pop();if(!t){this.state="DONE";return}this.setContained(t),this.colorCell(t.x,t.y,this.COLORS.finished),this.state="STARTWALK"}startWalk(){let t;do t=this.randomizedCells.pop();while(this.isContained(t));if(!t){this.state="DONE";return}this.colorCell(t.x,t.y,this.COLORS.current),this.walkPos=t,this.startWalkPos=t,this.state="WALK"}walk(){if(!this.walkPos){this.state="DONE";return}const t=this.randomizeValidDirections(this.walkPos)[0],e=p[t],s=this.walkPos.x+e.xd,l=this.walkPos.y+e.yd;if(this.setDirectionForCurrentWalk(this.walkPos,t),this.colorCell(this.walkPos.x,this.walkPos.y,this.COLORS.partial),this.walkPos={x:s,y:l},this.isContained(this.walkPos)){this.currentWalkTouched.forEach(o=>this.colorCell(o.x,o.y,this.COLORS.empty));const r={...this.startWalkPos};let i=this.getDirectionForCurrentWalk(r);for(;i;){this.setContained(r),this.colorCell(r.x,r.y,this.COLORS.finished),this.removeWall(r.x,r.y,i);const o=p[i];r.x+=o.xd,r.y+=o.yd,i=this.getDirectionForCurrentWalk(r)}this.state="STARTWALK",this.clearCurrentWalk()}else this.colorCell(s,l,this.COLORS.current)}}async function z(n){if(!(n<=0))if(n<=10){const t=performance.now();for(;performance.now()-t<n;);}else return new Promise(t=>setTimeout(t,n))}let x=0,m,y="stopped",d;self.onmessage=function({data:{method:n,maze:t,algorithm:e,delay:s=0}}){if(s!==void 0&&(x=s),t!==void 0&&(m=t,Object.setPrototypeOf(m,W.prototype)),e!==void 0&&!d)switch(e){case"Random":d=new O(m);break;case"RecursiveBacktracking":d=new P(m);break;case"Wilsons":d=new S(m);break;default:d=null,console.error(`Unknown algorithm: ${e}`);return}switch(n){case"play":y="playing",M();break;case"stop":y="stopped";break}};async function M(){for(;y==="playing";){const n=performance.now();if(!d?.performNextStep()){console.log(`${d?.constructor.name} complete - total time: ${Date.now()-(d?.startTime||0)}ms for ${d?.count} walls removed`),y="stopped",self.postMessage({method:"done"});return}await z(x-(performance.now()-n))}}})();
